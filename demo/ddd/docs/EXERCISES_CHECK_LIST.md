## チェックリスト

各課題完了時に確認してください：

- [x] 課題1: ユビキタス言語を定義した
  - [x] ビジネスの言葉で記述している（技術用語を使っていない）
  - [x] コードで使う用語と一致している
- [x] 課題2: 値オブジェクト（Money, Quantity, Email, ProductID）を実装した（テスト含む）
  - [x] すべて不変（イミュータブル）
  - [x] 等価性で比較している
  - [x] バリデーションロジックを含んでいる
  - [x] 値オブジェクト同士の演算を実装している（Quantity.Add(other Quantity)など）
  - [x] 計算結果も値オブジェクトの型で返している（Subtotal()やTotal()がMoneyを返す）
  - [x] **注意**: Currency型のスペルが正しいか確認（Currensyではなく）
- [x] 課題3: エンティティ（Order, OrderLine）を実装した（テスト含む）
  - [x] 一意の識別子を持っている
  - [x] ビジネスルールをカプセル化している
  - [x] 状態遷移のルールを実装している
  - [ ] 状態遷移図を作成した
  - [ ] すべての状態遷移についてテストを書いた
- [ ] 課題4: 集約を設計・実装した
  - [ ] Order集約（Order + OrderLine）
  - [ ] Stock集約（Stockエンティティ）
  - [ ] 各集約の不変条件を保護している
  - [ ] 重複商品チェックの実装（同じProductIDの明細を2回追加できない）
  - [ ] 合計金額の上限チェックの実装
  - [ ] 集約ルート経由でのみアクセスしている
  - [ ] 集約間はIDで参照している
  - [ ] Stockエンティティのテストを書いた（Reserve, Release, CanReserve）
- [ ] 課題5: ドメインサービスを実装した
  - [ ] StockAllocationService（Stockエンティティのメソッドを使用）
  - [ ] DiscountService
  - [ ] ドメインサービスはステートレス
  - [ ] StockAllocationServiceのテストを書いた（成功ケース、部分失敗ケース）
  - [ ] Stockの状態変化もテストで確認している
- [ ] 課題6: リポジトリパターンを実装した
  - [ ] OrderRepositoryインターフェース（ドメイン層）
  - [ ] StockRepositoryインターフェース（ドメイン層）
  - [ ] リポジトリ実装（インフラストラクチャ層）
- [ ] 課題7: ドメインイベントを実装した
- [ ] 課題8: アプリケーションサービスを実装した
  - [ ] StockRepositoryを使用して在庫を取得
  - [ ] StockAllocationServiceを使用して引当処理
  - [ ] 複数のリポジトリを協調させている
  - [ ] Order.Total()がMoney型を返している（値オブジェクトの一貫性）
- [ ] 課題9: コンテキストマップを作成した
  - [ ] OrderとStockが同じコンテキスト内にある理由を理解
  - [ ] 各コンテキストでの「在庫」の意味の違いを説明できる
- [ ] 課題10: 総合演習を完了した

### DDDベストプラクティスの確認（エリック・エヴァンスの原則）

#### 戦術的設計パターン
- [ ] **値オブジェクト**: 不変で、等価性で比較している
- [ ] **エンティティ**: 一意の識別子を持ち、ライフサイクルを通じて同一性を保つ
- [ ] **エンティティは自身のビジネスルールをカプセル化**している（リッチドメインモデル）
- [ ] **集約**: トランザクション整合性の境界を明確に定義している
- [ ] **集約ルート経由でのみ集約内のエンティティにアクセス**している
- [ ] **集約はできるだけ小さく保つ**（パフォーマンスのため）
- [ ] **集約間はIDで参照**している（オブジェクト参照を避ける）
- [ ] **ドメインサービス**: ステートレスで、複数の集約を協調させる役割に徹している
- [ ] **リポジトリ**: インターフェースはドメイン層、実装はインフラ層に配置
- [ ] **ファクトリ**: 複雑なオブジェクト生成ロジックをカプセル化している

#### 戦略的設計パターン
- [ ] **ユビキタス言語**: コードとドキュメントで一貫した用語を使用
- [ ] **境界づけられたコンテキスト**: コンテキストの境界を明確に定義
- [ ] **コンテキストマップ**: コンテキスト間の関係性を明示的に文書化
- [ ] **腐敗防止層**: 外部システムから自コンテキストを保護

#### レイヤード アーキテクチャ
- [ ] **アプリケーションサービスがトランザクション境界を管理**している
- [ ] **ドメインロジックはドメイン層に集中**し、アプリケーション層には配置していない
- [ ] **依存性の方向**: 外側から内側へ（インフラ層はドメイン層のインターフェースに依存）

#### アンチパターンの回避
- [ ] **貧血ドメインモデルを避ける**: エンティティがデータホルダーになっていない
- [ ] **神オブジェクトを避ける**: 責務が適切に分散されている
- [ ] **技術的分類でディレクトリを切らない**: ドメイン単位で整理している
