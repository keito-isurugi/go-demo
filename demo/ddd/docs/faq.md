## よくある質問（FAQ）

### Q1: 値オブジェクトとエンティティの違いは何ですか？
**A**:
- **値オブジェクト**: 同一性を持たず、**属性の値のみで比較**される（例: Money, Quantity）
- **エンティティ**: **一意の識別子で同一性を判断**される（例: Order, Customer）
- 例: 1000円と1000円は同じ（値オブジェクト）、注文ID123と注文ID456は違う注文（エンティティ）

### Q2: OrderLineはエンティティですか、値オブジェクトですか？
**A**: 設計次第です。
- **エンティティとして扱う場合**: OrderLineIDを持ち、注文明細の変更履歴を追跡する必要がある
- **値オブジェクトとして扱う場合**: 商品ID、数量、単価の組み合わせで識別され、変更時は新しいOrderLineを作成
- 本課題では**エンティティ的な側面**を持つが、**Order集約内に閉じている**ため外部から直接操作できない

### Q3: ドメインサービスとアプリケーションサービスの違いは？
**A**:
- **ドメインサービス**: **ドメインロジック**を実装（例: 在庫引当のビジネスルール）
  - ステートレス
  - 複数の集約を協調させる
  - ドメイン層に配置
- **アプリケーションサービス**: **ユースケースの実装**（例: 注文確定処理の流れ）
  - トランザクション境界を管理
  - リポジトリとドメインオブジェクトを協調させる
  - アプリケーション層に配置

### Q4: リポジトリのSaveメソッドは、新規作成と更新を両方行うのですか？
**A**: はい、一般的にDDDのリポジトリでは**SaveメソッドでCreate/Updateを両方扱います**。
```go
// SaveはUpsert的な動作をする
func (r *OrderRepositoryImpl) Save(ctx context.Context, order *Order) error {
    // 内部でIDの存在チェックを行い、INSERT/UPDATEを切り替える
}
```
これにより、アプリケーション層は集約が新規か既存かを意識する必要がなくなります。

### Q5: 課題4でOrderとStockが同じコンテキストなのに、課題9で分けるのはなぜですか？
**A**: これは**学習の段階的な進め方**によるものです。
- **課題1-8**: 単一の境界づけられたコンテキスト内での**戦術的設計**を学ぶ
  - Order集約とStock集約が密接に連携（トランザクション境界が同じ）
- **課題9**: 複数コンテキスト間の**戦略的設計**を学ぶ
  - 注文コンテキストと在庫管理コンテキストは**異なる関心事**を持つ
  - 同じ「在庫」でもコンテキストごとに意味が異なる（ユビキタス言語の境界）

実際のプロジェクトでは、**ビジネスの複雑さとチーム構成**に応じて境界を決定します。

### Q6: 貧血ドメインモデルとは何ですか？避けるべきですか？
**A**: 貧血ドメインモデルは**エンティティがデータホルダーになり、ビジネスロジックがサービスクラスに集中**している状態です。

```go
// ❌ 貧血ドメインモデル
type Order struct {
    ID     string
    Status string  // ただのデータ
}

type OrderService struct {}
func (s *OrderService) ConfirmOrder(order *Order) {
    order.Status = "Confirmed"  // ロジックがサービスに集中
}

// ✅ リッチドメインモデル
type Order struct {
    id     OrderID
    status OrderStatus
}

func (o *Order) Confirm() error {
    if o.status != Draft {
        return errors.New("can only confirm draft orders")
    }
    o.status = Confirmed  // ビジネスロジックはエンティティ内に
    return nil
}
```

DDDでは**リッチドメインモデルを推奨**します。ビジネスルールがエンティティ内にあることで、
ドメインの概念がコードで明確に表現されます。

### Q7: テストはどこまで書くべきですか？
**A**: DDDでは以下の優先順位でテストを書きます。
1. **ドメイン層の単体テスト**（最優先）
   - 値オブジェクト、エンティティ、ドメインサービスのビジネスルールを検証
   - 外部依存がないため高速
2. **アプリケーションサービスのテスト**
   - モックリポジトリを使用したユースケースの検証
3. **統合テスト**
   - 実際のDBを使った永続化層のテスト

ドメイン層のテストカバレッジは**80%以上**を目指しましょう。

### Q8: DDDは小規模プロジェクトには向いていませんか？
**A**: DDDの**戦術的設計パターン**（値オブジェクト、エンティティ、集約）は小規模プロジェクトでも有効です。
しかし、**戦略的設計**（境界づけられたコンテキスト、コンテキストマップ）は、
複雑さが低い場合は過剰になる可能性があります。

小規模プロジェクトでは：
- 値オブジェクトでドメイン概念を表現
- エンティティにビジネスルールをカプセル化
- リポジトリパターンで永続化を抽象化

これらのパターンを適用するだけでも、保守性の高いコードになります。
