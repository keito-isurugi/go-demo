# 概要と歴史的背景 - 4つのアーキテクチャの進化の流れ

## はじめに

ソフトウェアアーキテクチャは、ソフトウェア開発における問題を解決するために進化してきました。
このドキュメントでは、レイヤードアーキテクチャ、ヘキサゴナルアーキテクチャ、オニオンアーキテクチャ、クリーンアーキテクチャがどのような背景で生まれ、どのように進化してきたかを解説します。

---

## 1. アーキテクチャ進化の年表

```
1990年代初頭
    │
    ▼
┌─────────────────────────────────────────────────────────────┐
│  レイヤードアーキテクチャの普及                                │
│  ・クライアント/サーバーシステムの台頭                         │
│  ・3層アーキテクチャ（プレゼンテーション/ビジネス/データ）       │
└─────────────────────────────────────────────────────────────┘
    │
    │  約15年の実践で問題点が明確化
    │  ・ビジネスロジックとインフラの密結合
    │  ・テストの困難さ
    │  ・変更の影響範囲の大きさ
    ▼
2005年
┌─────────────────────────────────────────────────────────────┐
│  ヘキサゴナルアーキテクチャの提唱                              │
│  ・Alistair Cockburn による発表                              │
│  ・Ports & Adapters パターン                                 │
│  ・「外部を隔離する」という発想                                │
└─────────────────────────────────────────────────────────────┘
    │
    │  「Port/Adapter」という概念の確立
    │  ドメイン駆動設計(DDD)コミュニティでの採用
    ▼
2008年
┌─────────────────────────────────────────────────────────────┐
│  オニオンアーキテクチャの提唱                                  │
│  ・Jeffrey Palermo による発表                                │
│  ・「依存関係は内側に向かう」という原則                         │
│  ・ドメインモデルを中心に据える                                │
└─────────────────────────────────────────────────────────────┘
    │
    │  DDDコミュニティでの採用と洗練
    │  さらなる形式化の要求
    ▼
2012年
┌─────────────────────────────────────────────────────────────┐
│  クリーンアーキテクチャの提唱                                  │
│  ・Robert C. Martin (Uncle Bob) による発表                   │
│  ・ヘキサゴナル、オニオン等を統合・一般化                       │
│  ・より明確な層とポートの定義                                  │
└─────────────────────────────────────────────────────────────┘
    │
    ▼
現在
┌─────────────────────────────────────────────────────────────┐
│  各アーキテクチャの適材適所での活用                            │
│  ・マイクロサービス時代のアダプテーション                       │
│  ・言語/フレームワークごとのベストプラクティス                  │
└─────────────────────────────────────────────────────────────┘
```

---

## 2. レイヤードアーキテクチャの時代 (1990年代〜)

### 2.1 背景：クライアント/サーバーの台頭

1990年代、企業システムは**クライアント/サーバーモデル**へと移行しました。

```
【1980年代：メインフレーム時代】

    ┌─────────────┐
    │ メインフレーム │  ← 全ての処理がここ
    └─────────────┘
          ↑
    ┌─────────────┐
    │   端末      │  ← 表示のみ
    └─────────────┘


【1990年代：クライアント/サーバー時代】

    ┌─────────────┐      ┌─────────────┐
    │  クライアント │ ←→  │   サーバー   │
    │  (UI+処理)   │      │   (DB)      │
    └─────────────┘      └─────────────┘
```

この変化により、**アプリケーションをどう分割するか**という問題が顕在化しました。

### 2.2 3層アーキテクチャの誕生

解決策として生まれたのが**3層アーキテクチャ**です：

```
┌─────────────────────────────────────────┐
│         Presentation Layer              │
│      （ユーザーインターフェース）          │
│                                         │
│  責務: 画面表示、ユーザー入力の受付        │
├─────────────────────────────────────────┤
│                  ↓↑                     │
├─────────────────────────────────────────┤
│          Business Layer                 │
│        （ビジネスロジック）               │
│                                         │
│  責務: 業務ルール、計算、判断             │
├─────────────────────────────────────────┤
│                  ↓↑                     │
├─────────────────────────────────────────┤
│           Data Layer                    │
│         （データアクセス）                │
│                                         │
│  責務: データの永続化、取得               │
└─────────────────────────────────────────┘
```

### 2.3 採用された理由

1. **理解しやすい**: 水平方向の分割は直感的
2. **役割が明確**: 各層の責務が分かりやすい
3. **当時のツールに適合**: EJB、.NET などのフレームワークがこの構造を前提
4. **チーム分割が容易**: UI担当、ロジック担当、DB担当と分けられる

### 2.4 長年の実践で見えてきた問題

```
┌────────────────────────────────────────────────────────────┐
│                     問題1: DB中心設計                       │
├────────────────────────────────────────────────────────────┤
│                                                            │
│  レイヤードアーキテクチャでは、しばしば                       │
│  「まずDBテーブルを設計する」というアプローチになりがち        │
│                                                            │
│      DB設計 → データ層 → ビジネス層 → UI                    │
│                                                            │
│  結果: ビジネスロジックがDBの構造に引きずられる               │
│                                                            │
└────────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────────┐
│                   問題2: 密結合                             │
├────────────────────────────────────────────────────────────┤
│                                                            │
│  Business Layer                                            │
│       │                                                    │
│       └──→ Data Layer（具体的な実装に依存）                 │
│                 │                                          │
│                 └──→ PostgreSQL                            │
│                                                            │
│  ビジネス層のコード:                                        │
│  func (s *UserService) GetUser(id int) {                   │
│      // PostgreSQL固有のクエリ                              │
│      s.db.Query("SELECT ... FROM users WHERE id = $1", id) │
│  }                                                         │
│                                                            │
│  → DBを変えるとビジネス層も書き換えが必要                    │
│                                                            │
└────────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────────┐
│                   問題3: テストの困難さ                      │
├────────────────────────────────────────────────────────────┤
│                                                            │
│  ビジネスロジックをテストするには？                          │
│                                                            │
│  Business Layer → Data Layer → 実際のDB                    │
│                                                            │
│  選択肢:                                                   │
│  1. テスト用DBを用意 → セットアップが大変、遅い              │
│  2. モック化 → Data Layerの具体的な実装に依存していると困難  │
│                                                            │
└────────────────────────────────────────────────────────────┘
```

---

## 3. ヘキサゴナルアーキテクチャの登場 (2005年)

### 3.1 Alistair Cockburn の提案

2005年、Alistair Cockburnは**ヘキサゴナルアーキテクチャ**（別名: Ports & Adapters）を提唱しました。

> "アプリケーションを外部から隔離し、
> ポートとアダプターを通じて外部とやり取りすることで、
> 技術的な詳細から独立させる"

### 3.2 なぜ「六角形」か

```
┌─────────────────────────────────────────────────────────────┐
│  六角形に特別な意味はない                                    │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Alistair Cockburn曰く:                                     │
│  「四角形だと4面しか描けず、ポートの数が限定される印象を与える」│
│  「六角形なら複数のポートを自由に描ける」                     │
│                                                             │
│  つまり、「複数のポートがある」ことを視覚的に表現するための選択 │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 3.3 Port/Adapter という概念

```
                ┌───────────────────┐
    ┌──────────►│   Input Port      │
    │           │   (Interface)     │
    │           └─────────┬─────────┘
    │                     │
┌───┴───┐                 ▼
│Adapter│         ┌───────────────┐
│(HTTP) │         │  Application  │
└───────┘         │     Core      │
                  └───────┬───────┘
                          │
                  ┌───────▼───────┐
    ┌─────────────│  Output Port  │
    │             │  (Interface)  │
    │             └───────────────┘
    │
┌───▼───┐
│Adapter│
│ (DB)  │
└───────┘

Port: インターフェース（契約）
Adapter: Portの実装（具体的な技術）
```

### 3.4 重要な発想の転換

```
┌─────────────────────────────────────────────────────────────┐
│              レイヤードの発想                                 │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  UI → Business → DB                                        │
│                                                             │
│  DBが「下」にある = DBが基盤                                 │
│                                                             │
└─────────────────────────────────────────────────────────────┘
                            ↓
                       発想の転換
                            ↓
┌─────────────────────────────────────────────────────────────┐
│              ヘキサゴナルの発想                               │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Adapter → Port → Core ← Port ← Adapter                    │
│                                                             │
│  DBは「外」にある = DBは詳細、交換可能                       │
│  UIも「外」にある = UIも詳細、交換可能                       │
│                                                             │
│  Coreだけが本質                                              │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 3.5 ヘキサゴナルがもたらした影響

ヘキサゴナルアーキテクチャは、後続のアーキテクチャに大きな影響を与えました：

- **Port/Adapter** という用語と概念の確立
- **依存の方向を内側に向ける**という原則の明示
- **技術的詳細を外部に追いやる**という発想

これらの概念は、オニオン、クリーンアーキテクチャに直接継承されています。

---

## 4. オニオンアーキテクチャの登場 (2008年)

### 4.1 Jeffrey Palermo の問題提起

2008年、Jeffrey Palermoは自身のブログで**オニオンアーキテクチャ**を提唱しました。

> "従来のレイヤードアーキテクチャでは、ビジネスロジックがインフラストラクチャに依存している。
> これを逆転させ、インフラストラクチャがビジネスロジックに依存するようにすべきだ。"

### 4.2 発想の転換：玉ねぎのような同心円

```
【従来の発想：水平な層】

    ┌────────────────┐
    │  Presentation  │
    ├────────────────┤
    │   Business     │
    ├────────────────┤
    │     Data       │  ← ここが「基盤」という発想
    └────────────────┘


【オニオンの発想：同心円】

         ┌─────────────────────────────┐
         │        Infrastructure       │
         │   ┌─────────────────────┐   │
         │   │   Application       │   │
         │   │  ┌───────────────┐  │   │
         │   │  │    Domain     │  │   │  ← ここが「中心」
         │   │  └───────────────┘  │   │
         │   └─────────────────────┘   │
         └─────────────────────────────┘

    依存の方向: 外側 → 内側
```

### 4.3 ヘキサゴナルとの違い

```
┌─────────────────────────────────────────────────────────────┐
│            ヘキサゴナル vs オニオン                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ヘキサゴナル:                                               │
│  ・Port/Adapterという概念を強調                              │
│  ・Core内部の構造は未定義                                    │
│  ・入力/出力の対称性を重視                                   │
│                                                             │
│  オニオン:                                                   │
│  ・同心円という構造を強調                                    │
│  ・Core内部を Domain Model, Domain Service, Application に分割│
│  ・DDDとの親和性を明示                                       │
│                                                             │
│  共通点:                                                    │
│  ・依存は外側から内側へ                                      │
│  ・技術的詳細は外側に配置                                    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 4.4 ドメイン駆動設計(DDD)との親和性

オニオンアーキテクチャは**DDD (Domain-Driven Design)** の思想と非常に相性が良く、
DDDコミュニティで広く採用されました。

```
DDDの主張:
「ソフトウェアの核心は、それが解決するビジネスドメインにある」

          ↓ これを構造として表現

オニオンアーキテクチャ:
「ドメインモデルを中心に置き、技術的詳細は外側に追いやる」
```

---

## 5. クリーンアーキテクチャの誕生 (2012年)

### 5.1 Robert C. Martin の統合

2012年、Robert C. Martin（通称 Uncle Bob）は、複数の類似したアーキテクチャを分析し、
共通する本質を抽出して**クリーンアーキテクチャ**として発表しました。

```
┌─────────────────────────────────────────────────────────────┐
│              統合されたアーキテクチャたち                     │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ・Hexagonal Architecture (Ports & Adapters) - 2005年       │
│    Alistair Cockburn                                        │
│                                                             │
│  ・Onion Architecture - 2008年                              │
│    Jeffrey Palermo                                          │
│                                                             │
│  ・Screaming Architecture - 2011年                          │
│    Robert C. Martin                                         │
│                                                             │
│  ・DCI (Data, Context, Interaction)                         │
│    Trygve Reenskaug & James Coplien                         │
│                                                             │
│  ・BCE (Boundary-Control-Entity)                            │
│    Ivar Jacobson                                            │
│                                                             │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│               Clean Architecture (2012年)                   │
│                                                             │
│   これらに共通する本質を抽出し、一般化した原則                 │
└─────────────────────────────────────────────────────────────┘
```

### 5.2 Uncle Bob が見出した共通原則

```
┌─────────────────────────────────────────────────────────────┐
│                    共通する5つの原則                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. フレームワーク独立                                       │
│     アーキテクチャは特定のフレームワークに依存しない           │
│                                                             │
│  2. テスト可能                                               │
│     ビジネスルールはUI、DB、外部サービスなしでテスト可能       │
│                                                             │
│  3. UI独立                                                  │
│     UIを変更してもシステムの他の部分に影響しない              │
│                                                             │
│  4. データベース独立                                         │
│     DBをOracle→MongoDB に変えてもビジネスルールは不変        │
│                                                             │
│  5. 外部エージェント独立                                     │
│     ビジネスルールは外部世界について何も知らない               │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 5.3 明確な4層の定義

クリーンアーキテクチャでは、各層の責務がより明確に定義されました：

```
┌─────────────────────────────────────────────────────────────┐
│  Layer 1: Entities（エンティティ）                           │
├─────────────────────────────────────────────────────────────┤
│  ・企業全体のビジネスルールをカプセル化                       │
│  ・最も変更されにくい                                        │
│  ・他のすべてのレイヤーから独立                               │
│                                                             │
│  例: User, Order, Product のビジネスルール                   │
└─────────────────────────────────────────────────────────────┘
                            ↑ 依存
┌─────────────────────────────────────────────────────────────┐
│  Layer 2: Use Cases（ユースケース）                          │
├─────────────────────────────────────────────────────────────┤
│  ・アプリケーション固有のビジネスルール                       │
│  ・システムの入力と出力を定義                                 │
│  ・エンティティへの、エンティティからのデータフローを調整      │
│                                                             │
│  例: CreateUser, PlaceOrder, CalculateShipping              │
└─────────────────────────────────────────────────────────────┘
                            ↑ 依存
┌─────────────────────────────────────────────────────────────┐
│  Layer 3: Interface Adapters（インターフェースアダプター）    │
├─────────────────────────────────────────────────────────────┤
│  ・データ形式の変換                                          │
│  ・外部形式 ↔ ユースケース/エンティティ形式                   │
│                                                             │
│  例: Controller, Presenter, Repository実装, Gateway         │
└─────────────────────────────────────────────────────────────┘
                            ↑ 依存
┌─────────────────────────────────────────────────────────────┐
│  Layer 4: Frameworks & Drivers（フレームワークとドライバ）    │
├─────────────────────────────────────────────────────────────┤
│  ・最も外側のレイヤー                                        │
│  ・フレームワーク、ツール、DBなどの詳細                       │
│  ・「糊」としてのコード（他のレイヤーをつなぐ）               │
│                                                             │
│  例: Web Framework, DB Driver, External API Client          │
└─────────────────────────────────────────────────────────────┘
```

### 5.4 Input/Output ポートの明示

クリーンアーキテクチャの特徴的な貢献は、**ポート（境界）** を明示的に定義したことです：

```
┌─────────────────────────────────────────────────────────────┐
│                    ポートの概念                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│                   ┌─────────────┐                           │
│                   │  Use Case   │                           │
│                   │ (Interactor)│                           │
│                   └──────┬──────┘                           │
│                          │                                  │
│            ┌─────────────┼─────────────┐                    │
│            │             │             │                    │
│            ▼             │             ▼                    │
│     ┌────────────┐       │      ┌────────────┐              │
│     │Input Port  │       │      │Output Port │              │
│     │(Interface) │       │      │(Interface) │              │
│     └────────────┘       │      └────────────┘              │
│            ▲             │             ▲                    │
│            │             │             │                    │
│     ┌────────────┐       │      ┌────────────┐              │
│     │ Controller │       │      │ Repository │              │
│     │  (実装)    │       │      │   (実装)   │              │
│     └────────────┘       │      └────────────┘              │
│                          │                                  │
│     Input Port:  外部からユースケースを呼び出すためのIF       │
│     Output Port: ユースケースが外部を利用するためのIF         │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 6. 進化の本質：問題解決の歴史

### 6.1 各アーキテクチャが解決した問題

```
┌─────────────────────────────────────────────────────────────┐
│              レイヤードアーキテクチャ                         │
├─────────────────────────────────────────────────────────────┤
│  解決した問題:                                               │
│  ・コードの整理方法がなかった → 層で分割                      │
│  ・責務が混在していた → 各層に責務を割り当て                  │
│                                                             │
│  残った問題:                                                 │
│  ・ビジネスロジックがDBに依存 → テスト困難                    │
│  ・技術変更の影響が大きい                                    │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│              ヘキサゴナルアーキテクチャ                       │
├─────────────────────────────────────────────────────────────┤
│  解決した問題:                                               │
│  ・Port/Adapterで技術を隔離 → 交換可能に                     │
│  ・テスト容易に → Adapterを差し替えてテスト                   │
│                                                             │
│  残った問題:                                                 │
│  ・Core内部の構造が未定義                                    │
│  ・DDDとの関連が明示されていない                              │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│              オニオンアーキテクチャ                           │
├─────────────────────────────────────────────────────────────┤
│  解決した問題:                                               │
│  ・Core内部を層で構造化 → Domain Model/Service/Application   │
│  ・DDDとの親和性を明示 → Entity, Value Object が配置しやすい │
│                                                             │
│  残った問題:                                                 │
│  ・層の境界がやや曖昧                                        │
│  ・実装の指針が少ない                                        │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│              クリーンアーキテクチャ                           │
├─────────────────────────────────────────────────────────────┤
│  解決した問題:                                               │
│  ・層の責務を明確化 → 4層+ポートで構造を明示                  │
│  ・複数アーキテクチャの統合 → 共通言語の提供                  │
│  ・実装指針の提供 → Input/Outputポートパターン               │
│                                                             │
│  残った問題（トレードオフ）:                                  │
│  ・複雑さの増加                                              │
│  ・ボイラープレートコードの増加                               │
│  ・学習コストが高い                                          │
└─────────────────────────────────────────────────────────────┘
```

### 6.2 進化を貫く一貫したテーマ

```
┌─────────────────────────────────────────────────────────────┐
│                  変わらないテーマ                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. 関心の分離 (Separation of Concerns)                     │
│     → どの時代も「責務を分ける」ことを追求                    │
│                                                             │
│  2. ビジネスロジックの保護                                   │
│     → ビジネスの本質を技術的詳細から守る                     │
│                                                             │
│  3. 変更容易性                                               │
│     → ソフトウェアは変わるもの、変更に強い構造を求める        │
│                                                             │
│  4. テスタビリティ                                           │
│     → 品質を担保するためのテストのしやすさ                   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 7. 現代における位置づけ

### 7.1 マイクロサービス時代での適用

```
┌─────────────────────────────────────────────────────────────┐
│              マイクロサービスとの関係                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  マイクロサービスはシステム全体の分割方法                     │
│  各アーキテクチャはサービス内部の構造                         │
│                                                             │
│  ┌───────────┐  ┌───────────┐  ┌───────────┐               │
│  │ Service A │  │ Service B │  │ Service C │               │
│  │┌─────────┐│  │┌─────────┐│  │┌─────────┐│               │
│  ││ Clean   ││  ││ Onion   ││  ││ Layered ││               │
│  ││  Arch   ││  ││  Arch   ││  ││  Arch   ││               │
│  │└─────────┘│  │└─────────┘│  │└─────────┘│               │
│  └───────────┘  └───────────┘  └───────────┘               │
│                                                             │
│  各サービスは独立して適切なアーキテクチャを選択できる          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 7.2 現在の使い分け

```
シンプルなCRUD、プロトタイプ、小規模
        │
        └──→ レイヤードアーキテクチャ
              低コスト、素早く作れる

中規模、テスト重視、外部技術の交換可能性
        │
        └──→ ヘキサゴナルアーキテクチャ
              Port/Adapterで技術を隔離

中規模、DDD実践、ドメイン中心
        │
        └──→ オニオンアーキテクチャ
              DDDとの親和性が高い

大規模、長期運用、複雑なドメイン
        │
        └──→ クリーンアーキテクチャ
              初期コスト高いが変更に強い
```

---

## 8. まとめ

### 進化の流れを一言で

| アーキテクチャ | 年代 | キーワード |
|--------------|------|-----------|
| レイヤード | 1990年代〜 | 「層で分ける」 |
| ヘキサゴナル | 2005年〜 | 「Port/Adapterで隔離」 |
| オニオン | 2008年〜 | 「ドメインを中心に」 |
| クリーン | 2012年〜 | 「依存関係を制御する」 |

### 覚えておくべきこと

1. **問題が進化を生んだ**: 各アーキテクチャは前のものの問題を解決するために生まれた
2. **本質は同じ**: 関心の分離、ビジネスロジックの保護という目的は共通
3. **銀の弾丸はない**: プロジェクトに応じて適切なものを選ぶ
4. **理解してから適用**: アーキテクチャの「なぜ」を理解することが重要

---

## 参考文献

1. Cockburn, Alistair. "Hexagonal Architecture" (2005)
   - https://alistair.cockburn.us/hexagonal-architecture/

2. Palermo, Jeffrey. "The Onion Architecture" (2008)
   - https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/

3. Martin, Robert C. "The Clean Architecture" (2012)
   - https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html

4. Martin, Robert C. "Clean Architecture: A Craftsman's Guide to Software Structure and Design" (2017)
   - ISBN: 978-0134494166

---

次のドキュメント: [02_layered_architecture.md](./02_layered_architecture.md) - レイヤードアーキテクチャの詳細
