# N+1問題のパフォーマンス比較デモ

このプログラムは、データベースアクセスにおけるN+1問題とその解決方法を実際のパフォーマンスで比較するデモです。

## N+1問題とは

N+1問題は、データベースへのクエリが無駄に多く発行されるパフォーマンス問題です。

**問題のあるパターン:**
```
1. 全ユーザーを取得（1回のクエリ）
2. 各ユーザーの投稿を個別に取得（N回のクエリ）
→ 合計 1 + N 回のクエリ
```

**最適化されたパターン:**
```
1. 全ユーザーを取得（1回のクエリ）
2. 全投稿を一括取得（1回のクエリ）
→ 合計 2 回のクエリ
```

## 実行方法

```bash
cd demo/n_plus_1_problem
go run .
```

## ファイル構成

- [main.go](main.go) - メインプログラム（ベンチマーク実行）
- [models.go](models.go) - データベースモデルとサンプルデータ生成
- [n_plus_1.go](n_plus_1.go) - N+1問題のあるコード
- [optimized.go](optimized.go) - N+1問題を解決したコード
- [benchmark.go](benchmark.go) - ベンチマーク計測ユーティリティ

## データモデル

```
User (ユーザー)
  └─ Post (投稿) - 1対多
       └─ Comment (コメント) - 1対多
```

## ベンチマーク内容

### 1. ユーザーと投稿の取得
- **N+1問題あり**: 各ユーザーごとに投稿を個別取得
- **最適化版**: Preloadで一括取得

### 2. 投稿とコメントの取得
- **N+1問題あり**: 各投稿ごとにコメントを個別取得
- **最適化版**: Preloadで一括取得

### 3. 3階層データの取得（ユーザー → 投稿 → コメント）
- **N+1問題あり**: 各階層で個別にクエリを発行
- **最適化版**: ネストしたPreloadで一括取得

## 実行結果の見方

### パフォーマンス比較
デモを実行すると、以下のような比較結果が表示されます：

```
改善結果: ユーザーと投稿 (N+1問題あり) vs ユーザーと投稿 (Preload使用)
================================================================================
N+1問題あり: 411µs
最適化後:     175µs
改善率:       2.35倍速くなりました
短縮時間:     236µs
```

### SQLログ
実際に発行されるSQLを確認できます：

**N+1問題のあるコード:**
```sql
SELECT * FROM `users`                        -- 1回
SELECT * FROM `posts` WHERE user_id = 11     -- N回（ユーザーごと）
SELECT * FROM `posts` WHERE user_id = 12
SELECT * FROM `posts` WHERE user_id = 13
```

**最適化されたコード:**
```sql
SELECT * FROM `users`                                    -- 1回
SELECT * FROM `posts` WHERE `posts`.`user_id` IN (11,12,13)  -- 1回（一括）
```

## GORMでのN+1問題解決方法

### 悪い例（N+1問題あり）
```go
var users []User
db.Find(&users)

for i := range users {
    // 各ユーザーごとにクエリ発行！
    db.Where("user_id = ?", users[i].ID).Find(&users[i].Posts)
}
```

### 良い例（Preload使用）
```go
var users []User
// Preloadで関連データを事前読み込み
db.Preload("Posts").Find(&users)
```

### ネストした関連データの取得
```go
var users []User
// ネストしたPreloadで多段階の関連データを一括取得
db.Preload("Posts.Comments").Find(&users)
```

### 条件付きPreload
```go
var users []User
// 特定の条件に合う関連データのみを取得
db.Preload("Posts", "id >= ?", 10).Find(&users)
```

## パフォーマンスへの影響

レコード数が増えるほど、N+1問題の影響は大きくなります：

| ユーザー数 | N+1問題のクエリ数 | 最適化版のクエリ数 |
|----------|----------------|----------------|
| 10人     | 11回           | 2回            |
| 100人    | 101回          | 2回            |
| 1000人   | 1001回         | 2回            |

## まとめ

- **N+1問題**: 各レコードごとに追加のクエリが発行される
- **解決策**: GORMの`Preload()`を使用
- **効果**: クエリ数を大幅に削減し、パフォーマンスが向上
- **特に重要**: レコード数が多い場合、効果は劇的

## 関連リンク

- [GORM公式ドキュメント - Preloading](https://gorm.io/docs/preload.html)
- [GORM公式ドキュメント - Associations](https://gorm.io/docs/has_many.html)
